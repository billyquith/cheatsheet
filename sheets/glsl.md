

GLSL
====

Vertex Shader
-------------

- [OpenGL wiki](https://www.opengl.org/wiki/Vertex_Shader)

#### Built-in inputs

```glsl
in int gl_VertexID;
in int gl_InstanceID;
```

- `gl_VertexID​`: index of vertex being processed. When using non-indexed rendering, it is the
  effective index of the current vertex (the number of vertices processed + the first​ value). For
  indexed rendering, it is the index used to fetch this vertex from the buffer. Note: gl_VertexID​
  will have the base vertex applied to it.  
- `gl_InstanceID​`: index of instance when doing some form of instanced rendering. Instance
  count always starts at 0, even when using base instance calls. When not using instanced
  rendering, this value 0.

#### User input

```glsl
layout(location = 2) in vec4 a_vec;
```

- `layout(location = #)` optional attribute index. Matrices take one index per column.

#### Output

``` glsl
out gl_PerVertex
{
  vec4 gl_Position;
  float gl_PointSize;
  float gl_ClipDistance[];
};
```

- `gl_PerVertex`​ defines *interface block* for outputs. Block is defined without instance name, 
  so prefixing not required.
- `gl_Position​`: clip-space output position of the current vertex.
- `gl_PointSize​`: pixel width/height of point being rasterized, when rendering point primitives.
  Clamped to the `GL_POINT_SIZE_RANGE`.
- `gl_ClipDistance​`: allows the shader to set the distance from the vertex to each user-defined
  clipping half-space.


Fragment Shader
---------------

- [OpenGL wiki](https://www.opengl.org/wiki/Fragment_Shader)
- Fragment shaders are technically an optional shader stage, e.g. shadow mapping. If none, Fragment
  output colour values undefined. However, depth and stencil values output = input. 
- Fragment shaders have access to the `discard`​ command. Causes output values to be discarded.
  Fragment does not proceed to next pipeline stages.

#### Built-in inputs

``` glsl
in vec4 gl_FragCoord;
in bool gl_FrontFacing;
in vec2 gl_PointCoord;
```
``` glsl
// All the following are allowed redeclaration that change behavior
layout(origin_upper_left) in vec4 gl_FragCoord;
layout(pixel_center_integer) in vec4 gl_FragCoord;
layout(origin_upper_left, pixel_center_integer) in vec4 gl_FragCoord;
```

- `gl_FragCoord​`: location of the fragment in window space. XYZ components are the *window-space*
  position of the fragment. Z will be written to the depth buffer if `gl_FragDepth`​ not written
  to. W component​ is 1/Wclip, where Wclip is the interpolated W of clip-space `gl_Position`​ from
  last Vertex Processing stage. The coordinate space of `gl_FragCoord`​ can be modified by redeclaring it:
  - `layout(origin_upper_left) in vec4 gl_FragCoord;` : This means that the origin for
    `gl_FragCoord​`'s window-space will be the upper-left of the screen, rather than the usual
    lower-left.
  - `layout(pixel_center_integer​) in vec4 gl_FragCoord;` : OpenGL window space is defined so pixel
    centers are on *half-integer* boundaries. Center of lower-left pixel is (0.5, 0.5). Using
    `pixel_center_integer`​​ adjust gl_FragCoord​ such that whole integer values represent pixel
    centers. Both of these exist to be compatible with D3D's window space. Unless you need your
    shaders to have this compatibility, you are advised not to use these features.
- `gl_FrontFacing​`: True if this fragment was generated by the front-face of the primitive; else
  false if back. Only triangles have a back face; else this always true.
  
- `gl_PointCoord​`: Location *within a point primitive*; defines fragment position relative to side
  of point, range [0,1], (0,0) upper-left. Points effectively window-space squares of certain pixel
  size, defined by single vertex. Origin can be switched to a bottom-left origin by calling
  `glPointParameteri(GL_POINT_SPRITE_COORD_ORIGIN, GL_LOWER_LEFT);​`

**OpenGL 4.0+**:

```glsl
in int gl_SampleID;
in vec2 gl_SamplePosition;
in int gl_SampleMaskIn[];
```

- `gl_SampleID​`: Current sample that this fragment is rasterized for. *Warning:* Using this forces
  shader evaluation per-sample. Since much of the point of multisampling is to avoid that, you
  should use it only when you must.
- `gl_SamplePosition​`: This is the location of the current sample for the fragment within the
  pixel's area, with values, range [0,1]. Origin is the bottom-left of the pixel. *Warning:* Using
  this forces this shader evaluation per-sample. Since much of the point of multisampling is to
  avoid that, you should use it only when you must.
- `gl_SampleMaskIn​`: When using multisampling, this variable contains a bitfield for the sample
  mask of the fragment being generated. The array is as long as needed to fill in the number of
  samples supported by the GL implementation.

Some Fragment shader built-in inputs will take values specified by OpenGL, but these values can be overridden by user control.

in float gl_ClipDistance[];
in int gl_PrimitiveID;

gl_ClipDistance​
This array contains the interpolated clipping plane half-spaces, as output for vertices from the last Vertex Processing stage.
gl_PrimitiveID​
This value is the index of the current primitive being rendered by this drawing command. This includes any Tessellation applied to the mesh, so each individual primitive will have a unique index.
However, if a Geometry Shader is active, then the gl_PrimitiveID​ is exactly and only what the GS provided as output. Normally, gl_PrimitiveID​ is guaranteed to be unique, so if two FS invocations have the same primitive ID, they come from the same primitive. But if a GS is active and outputs non-unique values, then different fragment shader invocations for different primitives will get the same value. If the GS did not output a value for gl_PrimitiveID​, then the fragment shader gets an undefined value.

Functions
---------

Types
-----

The OpenGL Shading Language supports the following basic data types, grouped as follows.

### Transparent types

Type | Meaning
---- | -------
`void` | for functions that do not return a value
`bool` | a conditional type, taking on values of true or false
`int` | a signed integer
`uint` | an unsigned integer
`float` | a single-precision floating-point scalar
`double` | a double-precision floating-point scalar
`vecN` | a multi-component single-precision floating-point vector. N = [2,3,4].
`dvecN` | a multi-component double-precision floating-point vector. N = [2,3,4].
`bvecN` | a multi-component Boolean vector. N = [2,3,4].
`ivecN` | a multi-component signed integer vector. N = [2,3,4].
`ivecN` | a multi-component unsigned integer vector. N = [2,3,4].
`matN` | an N×N single-precision floating-point matrix. N = [2,3,4].
`matNxN` | same as a `matN`
`matNxM` | an NxM double-precision floating-point matrix with N columns and M rows. N,M = [2,3,4].
`dmatN` | an N×N double-precision floating-point matrix. N = [2,3,4].
`dmatNxN` | same as a `dmatN`
`dmatNxM` | an NxM double-precision floating-point matrix with N columns and M rows. N,M = [2,3,4].

### Floating-Point Opaque Types

Type | Meaning
---- | -------
`sampler1D`, `image1D` | a handle for accessing a 1D texture
`sampler2D`, `image2D` | a handle for accessing a 2D texture
`sampler3D`, `image3D` | a handle for accessing a 3D texture
`samplerCube`, `imageCube` | a handle for accessing a cube mapped texture
`sampler2DRect`, `image2DRect` | a handle for accessing a rectangle texture
`sampler1DArray`, `image1DArray` | a handle for accessing a 1D array texture
`sampler2DArray`, `image2DArray` | a handle for accessing a 2D array texture
`samplerBuffer`, `imageBuffer` | a handle for accessing a buffer texture
`sampler2DMS`, `image2DMS` | a handle for accessing a 2D multi-sample texture
`sampler2DMSArray`, `image2DMSArray` | a handle for accessing a 2D multi-sample array texture
`samplerCubeArray`, `imageCubeArray` | a handle for accessing a cube map array texture
`sampler1DShadow` |` `a handle for accessing a 1D depth texture with comparison
`sampler2DShadow` | a handle for accessing a 2D depth texture with comparison
`sampler2DRectShadow` | a handle for accessing a rectangle texture with comparison
`sampler1DArrayShadow` | a handle for accessing a 1D array depth texture with comparison
`sampler2DArrayShadow` | a handle for accessing a 2D array depth texture with comparison
`samplerCubeShadow` | a handle for accessing a cube map depth texture with comparison
`samplerCubeArrayShadow` | a handle for accessing a cube map array depth texture with comparison

TODO - add other opaque types

### Storage Qualifiers

Variable declarations may have at most one storage qualifier specified in front of the type. These are summarized as

Storage Qualifier | Meaning
----------------- | -------
none: default | local read/write memory, or an input parameter to a function
`const` | a variable whose value cannot be changed
`in` | linkage into a shader from a previous stage, variable is copied in
`out` | linkage out of a shader to a subsequent stage, variable is copied out
`attribute` | compatibility profile only and vertex language only; same as in when in a vertex shader
`uniform` | value does not change across the primitive being processed, uniforms form the linkage between a shader, OpenGL, and the application
`varying` | compatibility profile only and vertex and fragment languages only; same as out when in a vertex shader and same as in when in a fragment shader
`buffer` | value is stored in a buffer object, and can be read or written both by shader invocations and the OpenGL API
`shared` | compute shader only; variable storage is shared across all work items in a local work group


Glossary
--------

- **Compute Processor**: programmable unit that operates independently from the other shader
  processors. Compilation units written in the OpenGL Shading Language to run on this processor are
  called *compute shaders*. It does not have any predefined inputs nor any fixed-function outputs.
  It is not part of the graphics pipeline and its visible side effects are through changes to
  images, storage buffers, and atomic counters. A compute shader operates on a group of work items
  called a *work group*.
- **Fragment Processor**: programmable unit that operates on fragment values and their associated
  data. Compilation units written in the OpenGL Shading Language to run on this processor are
  called *fragment shaders*. A fragment shader cannot change a fragment's (x, y) position. Access
  to neighboring fragments is not allowed. The values computed by the fragment shader are
  ultimately used to update framebuffer memory or texture memory, depending on the current OpenGL
  state and the OpenGL command that caused the fragments to be generated.  
- **Geometry Processor**: programmable unit that operates on data for incoming vertices for a
  primitive assembled after vertex processing and outputs a sequence of vertices forming output
  primitives. Compilation units written in the OpenGL Shading Language to run on this processor are
  called *geometry shaders*. This single invocation can emit a variable number of vertices that are
  assembled into primitives of a declared output primitive type and passed to subsequent pipeline
  stages.
- **Opaque Types**: opaque handles to other objects. These objects are accessed through built-in
  functions, not through direct reading or writing of the declared variable. They can only be
  declared as function parameters or in uniform-qualified variables.  
- **Output Variables**: Declared using the storage qualifier `out`. They form the output interface
  between the declaring shader and the subsequent stages of the OpenGL pipeline. Output variables
  must be declared at global scope. During shader execution they will behave as normal unqualified
  global variables. Their values are copied out to the subsequent pipeline stage on shader exit.
  Only output variables that are read by the subsequent pipeline stage need to be written; it is
  allowed to have superfluous declarations of output variables.  
- **Uniform Variables**: The `uniform` qualifier is used to declare global variables whose values
  are the same across the entire primitive being processed. All uniform variables are *read-only*
  and are initialized externally either at link time or through the API. The link-time initial
  value is either the value of the variable's initializer, if present, or 0 if no initializer is
  present. Opaque types cannot have initializers, or a compile-time error results.  
- **Vertex Processor**: programmable unit that operates on incoming vertices and their
  associated data. Compilation units written in the OpenGL Shading Language to run on this
  processor are called *vertex shaders*.  
- **Work group**: a collection of shader invocations that execute the same code, potentially in
  parallel. An invocation within a work group may share data with other members of the same work
  group through shared variables and issue memory and control barriers to synchronize with other
  members of the same work group.

### Links
  
- Source for this doc: https://www.opengl.org/registry/doc/GLSLangSpec.4.40.pdf
- [GLSL wikipedia](https://en.wikipedia.org/wiki/OpenGL_Shading_Language)
- [OpenGL wiki GLSL](https://www.opengl.org/wiki/OpenGL_Shading_Language)

